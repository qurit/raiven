{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Radiology Environment of the Future Radiology + AI + Environment = Raiven Artificial intelligence (AI) is finding an increasing number of applications in nuclear medicine and radiology. Deep learning models have been used to improve image quality, automate image segmentation, and aid in disease classification. Models that combine learned features, radiomic features, and clinical information can be used to predict disease progression, treatment outcome and survival. However, translation of such models/algorithms into clinical trials or standard of care applications is often nontrivial due to the lack of an appropriate framework for model deployment. The aim of this project is to develop such a framework that satisfies the following design specifications: 1. Allows easy combination of different algorithms to create pipelines with multistep workflows 2. Works with existing workstations available to physicians/researchers 3. Allows the deployment of models developed in any programming language without the need for cumbersome and time-consuming configuration 4. Is easy to deploy and use. The RAIVEN (Radiology AI Virtual ENvironment) framework represents a vision of a new radiology environment that incorporates AI tools to better treat and diagnose disease. Deployment The easiest way to deploy Raiven is using docker. Raiven comes with a preconfigured compose file. $ docker-compose up -d Config Configuration of Raiven can be done in multiple places. If you are using docker, configuration can be done by modifying the .env file. Backend configuration can also be done by modifying /backend/config.py whilst the frontend configuration can be done by modifying /frontend/nuxt.config.js . Configuration can also be done by setting environment variables. The environment variables which can be set are found in /backend/config.py . Proudly Sponsored by Qurit","title":"Overview"},{"location":"#deployment","text":"The easiest way to deploy Raiven is using docker. Raiven comes with a preconfigured compose file. $ docker-compose up -d","title":"Deployment"},{"location":"#config","text":"Configuration of Raiven can be done in multiple places. If you are using docker, configuration can be done by modifying the .env file. Backend configuration can also be done by modifying /backend/config.py whilst the frontend configuration can be done by modifying /frontend/nuxt.config.js . Configuration can also be done by setting environment variables. The environment variables which can be set are found in /backend/config.py . Proudly Sponsored by Qurit","title":"Config"},{"location":"backend/","text":"Backend The backend is built primarily using FastAPI in Python, with a PostgreSQL database. Models The models define the entity-relationship model in the database, and can be found under \\backend\\api\\models . Schemas The definitions of how data is to be sent and received by the internal API. They can be found under \\backend\\api\\schemas . Routes The internal API routes that can be used by the frontend, and pull information from the database. They can be found under \\backend\\api\\routes . Middleware for the routes can be found under \\backend\\api\\middleware . Pipelining Logic Basically magic by Adam.","title":"Backend"},{"location":"backend/#backend","text":"The backend is built primarily using FastAPI in Python, with a PostgreSQL database.","title":"Backend"},{"location":"backend/#models","text":"The models define the entity-relationship model in the database, and can be found under \\backend\\api\\models .","title":"Models"},{"location":"backend/#schemas","text":"The definitions of how data is to be sent and received by the internal API. They can be found under \\backend\\api\\schemas .","title":"Schemas"},{"location":"backend/#routes","text":"The internal API routes that can be used by the frontend, and pull information from the database. They can be found under \\backend\\api\\routes . Middleware for the routes can be found under \\backend\\api\\middleware .","title":"Routes"},{"location":"backend/#pipelining-logic","text":"Basically magic by Adam.","title":"Pipelining Logic"},{"location":"containers/","text":"Containers Docker Containers are the building blocks of Raiven's Pipelines. Detailed below is the process of creating and uploading a Container so you can use it in a Pipeline. Language Support RAIVEN supports any language so long as you can containerize your algorithm. Creating a Container When creating a Container, you should have a Dockerfile all the source code required to run your algorithm . In general, all dockerfiles will need: Install any dependencies you may require Set the following environment variables: RAIVEN_INPUT_DIR=/mnt/raiven/input RAIVEN_OUTPUT_DIR=/mnt/raiven/output Provide a command to execute your algorithm Dockerfile Example Below is a sample dockerfile used when creating a Container in python. FROM python:3.8-slim WORKDIR /src RUN pip install pydicom numpy COPY . . CMD python main.py Algorithm Example An example algorithm that runs inside the Container is shown below. In the code below, the algorithm reads all the dicom files from the input directory, doubles the value of their pixels, and then saves the new image to the output directory. import os from pydicom import dcmread INPUT_DIR = os . environ [ 'RAIVEN_INPUT_DIR' ] OUTPUT_DIR = os . environ [ 'RAIVEN_OUTPUT_DIR' ] if __name__ == '__main__' : for root , dirs , files in os . walk ( INPUT_DIR ): for file in files : if file . endswith ( '.dcm' ): ds = dcmread ( os . path . join ( root , file )) pixels = ds . pixel_array pixels = pixels * 2 ds . PixelData = pixels . tobytes () ds . save_as ( os . path . join ( OUTPUT_DIR , file )) Note If you did not set up the input and output environment variables in the Dockerfile, you can set the input and output directories to be /mnt/raiven/input and /mnt/raiven/output . Uploading a Container Go to the Containers page Click and fill out the form You must provide a Container name and an attached file (your zipped Dockerfile and main algorithm from Step 1) Click to save your Container Warning Make sure to place both your dockerfile and source files in a zip file before uploading Editing a Container Go to the Containers page Click next to the Container to be edited Alternatively, click to completely delete the Container Edit the form Click to save","title":"Containers"},{"location":"containers/#containers","text":"Docker Containers are the building blocks of Raiven's Pipelines. Detailed below is the process of creating and uploading a Container so you can use it in a Pipeline. Language Support RAIVEN supports any language so long as you can containerize your algorithm.","title":"Containers"},{"location":"containers/#creating-a-container","text":"When creating a Container, you should have a Dockerfile all the source code required to run your algorithm . In general, all dockerfiles will need: Install any dependencies you may require Set the following environment variables: RAIVEN_INPUT_DIR=/mnt/raiven/input RAIVEN_OUTPUT_DIR=/mnt/raiven/output Provide a command to execute your algorithm","title":"Creating a Container"},{"location":"containers/#dockerfile-example","text":"Below is a sample dockerfile used when creating a Container in python. FROM python:3.8-slim WORKDIR /src RUN pip install pydicom numpy COPY . . CMD python main.py","title":"Dockerfile Example"},{"location":"containers/#algorithm-example","text":"An example algorithm that runs inside the Container is shown below. In the code below, the algorithm reads all the dicom files from the input directory, doubles the value of their pixels, and then saves the new image to the output directory. import os from pydicom import dcmread INPUT_DIR = os . environ [ 'RAIVEN_INPUT_DIR' ] OUTPUT_DIR = os . environ [ 'RAIVEN_OUTPUT_DIR' ] if __name__ == '__main__' : for root , dirs , files in os . walk ( INPUT_DIR ): for file in files : if file . endswith ( '.dcm' ): ds = dcmread ( os . path . join ( root , file )) pixels = ds . pixel_array pixels = pixels * 2 ds . PixelData = pixels . tobytes () ds . save_as ( os . path . join ( OUTPUT_DIR , file )) Note If you did not set up the input and output environment variables in the Dockerfile, you can set the input and output directories to be /mnt/raiven/input and /mnt/raiven/output .","title":"Algorithm Example"},{"location":"containers/#uploading-a-container","text":"Go to the Containers page Click and fill out the form You must provide a Container name and an attached file (your zipped Dockerfile and main algorithm from Step 1) Click to save your Container Warning Make sure to place both your dockerfile and source files in a zip file before uploading","title":"Uploading a Container"},{"location":"containers/#editing-a-container","text":"Go to the Containers page Click next to the Container to be edited Alternatively, click to completely delete the Container Edit the form Click to save","title":"Editing a Container"},{"location":"frontend/","text":"Frontend The frontend is built primarily using Vue , Vuetify , and Nuxt in JavaScript. Pages The pages directory contains the routes for the various pages of the application. You can modify the layour and appearance of a page in \\frontend\\pages , or simply add another page by creating a new file. If you created a new page, you can also update the navigation drawer in \\frontend\\layouts\\default.vue . Components Components can be found under \\frontend\\components and are categorized and grouped together by their functionality. You can check the official Vue Style Guide to see how your components should be organized. You can find a variety of Material Design ocons to use here Store The Vuex store pulls information from the backend and contains relevant information that can be used among other components in the project. You can modify the store in \\frontend\\store . You can communicate with the backend using axios , a promise based HTTP client. Generic requests have been implemented in \\frontend\\api\\index.js . Images If you would like to add or modify images, you can find them under \\frontend\\static .","title":"Frontend"},{"location":"frontend/#frontend","text":"The frontend is built primarily using Vue , Vuetify , and Nuxt in JavaScript.","title":"Frontend"},{"location":"frontend/#pages","text":"The pages directory contains the routes for the various pages of the application. You can modify the layour and appearance of a page in \\frontend\\pages , or simply add another page by creating a new file. If you created a new page, you can also update the navigation drawer in \\frontend\\layouts\\default.vue .","title":"Pages"},{"location":"frontend/#components","text":"Components can be found under \\frontend\\components and are categorized and grouped together by their functionality. You can check the official Vue Style Guide to see how your components should be organized. You can find a variety of Material Design ocons to use here","title":"Components"},{"location":"frontend/#store","text":"The Vuex store pulls information from the backend and contains relevant information that can be used among other components in the project. You can modify the store in \\frontend\\store . You can communicate with the backend using axios , a promise based HTTP client. Generic requests have been implemented in \\frontend\\api\\index.js .","title":"Store"},{"location":"frontend/#images","text":"If you would like to add or modify images, you can find them under \\frontend\\static .","title":"Images"},{"location":"pipelines/","text":"Pipelines Creating a Pipeline Go to the Pipelines page Click and fill out the form You must provide a Pipeline name You may provide an AE title if you would like this Pipeline to automatically run upon receiving a specific DICOM instance You will be brought to the Pipeline creation canvas board Click on the top left of the canvas to view your Containers From the right-hand Container list, click on the Container card to add it to the canvas Drag your Containers around to build your pipeline flow Connect your Containers with the small nodes at left (input) and right (output) of the cards The link between Containers should start from a Container's right side node to another Container's left side While dragging the link, hover over the input node, and when it has changed colours, you can release the link to complete the connection. If you would like your Pipeline results to be sent to another DICOM node, you can add the default Dicom Output Container to the end of your flow. To designate the DICOM node to send to, add the node's host and port and select it in the Dicom Output Container's dropdown menu. If you would like your Pipeline to receive from a DICOM node, you can add the default Dicom Input Container to the beginning of your flow. To designate the DICOM node to receive from, add the node's host and port and select it in the Dicom Input Container's dropdown menu. You can set rules to decide when to run the Pipeline under specific conditions. Click to save your Pipeline Editing a Pipeline Go to the Pipelines page Click the Pipeline row that you want to view or edit You can edit the Pipeline flow Edit the canvas board the same way you did so when first creating the Pipeline Delete Containers from the canvas with the on the Container card, and delete Container connections by hovering over the connection arrow and clicking the X Click to save your changes You can edit the Pipeline's info Click on the top left Click to edit your Pipeline's name, AE title, or shareability Click to save your changes Running a Pipeline Go to the Runs page From the received DICOM instances, choose to send the Node , Patient , Study , or Series to a Pipeline by clicking on the respective row Select which pipeline you would like to send the images to Click Send to start the Pipeline Run Viewing your Run Results Go to the Runs page Navigate to the \"Pipeline Run Results\" table Click next to the repsective pipeline run to download the results as a zip file Viewing your files from Pipeline Runs Go to the Files page Click next to the respective file to download it Viewing a Pipeline's Runs Go to the Pipelines page Click the pipeline row that you want to view Click on the top left to view this pipeline's runs Information about a run's Containers and errors can be found here as well","title":"Pipelines"},{"location":"pipelines/#pipelines","text":"","title":"Pipelines"},{"location":"pipelines/#creating-a-pipeline","text":"Go to the Pipelines page Click and fill out the form You must provide a Pipeline name You may provide an AE title if you would like this Pipeline to automatically run upon receiving a specific DICOM instance You will be brought to the Pipeline creation canvas board Click on the top left of the canvas to view your Containers From the right-hand Container list, click on the Container card to add it to the canvas Drag your Containers around to build your pipeline flow Connect your Containers with the small nodes at left (input) and right (output) of the cards The link between Containers should start from a Container's right side node to another Container's left side While dragging the link, hover over the input node, and when it has changed colours, you can release the link to complete the connection. If you would like your Pipeline results to be sent to another DICOM node, you can add the default Dicom Output Container to the end of your flow. To designate the DICOM node to send to, add the node's host and port and select it in the Dicom Output Container's dropdown menu. If you would like your Pipeline to receive from a DICOM node, you can add the default Dicom Input Container to the beginning of your flow. To designate the DICOM node to receive from, add the node's host and port and select it in the Dicom Input Container's dropdown menu. You can set rules to decide when to run the Pipeline under specific conditions. Click to save your Pipeline","title":"Creating a Pipeline"},{"location":"pipelines/#editing-a-pipeline","text":"Go to the Pipelines page Click the Pipeline row that you want to view or edit You can edit the Pipeline flow Edit the canvas board the same way you did so when first creating the Pipeline Delete Containers from the canvas with the on the Container card, and delete Container connections by hovering over the connection arrow and clicking the X Click to save your changes You can edit the Pipeline's info Click on the top left Click to edit your Pipeline's name, AE title, or shareability Click to save your changes","title":"Editing a Pipeline"},{"location":"pipelines/#running-a-pipeline","text":"Go to the Runs page From the received DICOM instances, choose to send the Node , Patient , Study , or Series to a Pipeline by clicking on the respective row Select which pipeline you would like to send the images to Click Send to start the Pipeline Run","title":"Running a Pipeline"},{"location":"pipelines/#viewing-your-run-results","text":"Go to the Runs page Navigate to the \"Pipeline Run Results\" table Click next to the repsective pipeline run to download the results as a zip file","title":"Viewing your Run Results"},{"location":"pipelines/#viewing-your-files-from-pipeline-runs","text":"Go to the Files page Click next to the respective file to download it","title":"Viewing your files from Pipeline Runs"},{"location":"pipelines/#viewing-a-pipelines-runs","text":"Go to the Pipelines page Click the pipeline row that you want to view Click on the top left to view this pipeline's runs Information about a run's Containers and errors can be found here as well","title":"Viewing a Pipeline's Runs"},{"location":"uploading-data/","text":"DICOM is the standard for the communication and management of medical images and related data. Raiven has built in support for AE 's to upload DICOM data directly to a Raiven server and allows for three different options for pushing files. Which option you select is dictated by the ae_title you associate with when making the connection to the Raiven server. The available options are: pushing DICOM globally, pushing DICOM to a specific user, and pushing DICOM to a specific pipeline. Pushing DICOM globally This option saves your DICOM data on the Raiven server and makes the data available to all users on the network. This option requires an ae_title of \"RAIVEN\". Avoid utilizing this option if your data contains private information. Pushing DICOM to a specific user This option saves your DICOM data on the Raiven server but only makes the data available to a specific user. This option requires an ae_title of \"RVU-{username}\" where \"{username}\" is replaced by the username of the account you wish to send data to. Use this option if your data contains private information that you do not want other users accessing. Pushing DICOM to a specific pipeline This option will immediately send your DICOM data to an existing pipeline on the Raiven server for processing. The DICOM files that you send in this manner will not be stored within the application and will eventually be deleted after the pipeline has finished processing it. Aditionally, one can configure the pipeline to send the resulting data directly back to the AE that sent it in. This option requires an ae_title of \"RVP-{Pipeline AE Title}\" where \"{Pipeline AE Title}\" is replaced by the ae title of the desired pipeline. The AE title of a pipeline can be configured in RAIVEN. Example code Included in the project is an example SCP script in which you can test performing a C-Store within your desired Raiven instance. To do this, issue the following commands $ cd backend \\t ests \\t est_dicom $ python . \\t est_scp.py Note that you must first configure the UPLOAD_DIR and UPLOAD_AE_TITLE variables within the script prior to running the program. The UPLOAD_AE_TITLE will dictate what option is chosen for pushing the dicom data. Proudly Sponsored by Qurit","title":"Uploading data"},{"location":"uploading-data/#pushing-dicom-globally","text":"This option saves your DICOM data on the Raiven server and makes the data available to all users on the network. This option requires an ae_title of \"RAIVEN\". Avoid utilizing this option if your data contains private information.","title":"Pushing DICOM globally"},{"location":"uploading-data/#pushing-dicom-to-a-specific-user","text":"This option saves your DICOM data on the Raiven server but only makes the data available to a specific user. This option requires an ae_title of \"RVU-{username}\" where \"{username}\" is replaced by the username of the account you wish to send data to. Use this option if your data contains private information that you do not want other users accessing.","title":"Pushing DICOM to a specific user"},{"location":"uploading-data/#pushing-dicom-to-a-specific-pipeline","text":"This option will immediately send your DICOM data to an existing pipeline on the Raiven server for processing. The DICOM files that you send in this manner will not be stored within the application and will eventually be deleted after the pipeline has finished processing it. Aditionally, one can configure the pipeline to send the resulting data directly back to the AE that sent it in. This option requires an ae_title of \"RVP-{Pipeline AE Title}\" where \"{Pipeline AE Title}\" is replaced by the ae title of the desired pipeline. The AE title of a pipeline can be configured in RAIVEN.","title":"Pushing DICOM to a specific pipeline"},{"location":"uploading-data/#example-code","text":"Included in the project is an example SCP script in which you can test performing a C-Store within your desired Raiven instance. To do this, issue the following commands $ cd backend \\t ests \\t est_dicom $ python . \\t est_scp.py Note that you must first configure the UPLOAD_DIR and UPLOAD_AE_TITLE variables within the script prior to running the program. The UPLOAD_AE_TITLE will dictate what option is chosen for pushing the dicom data. Proudly Sponsored by Qurit","title":"Example code"}]}